   HTTP是为构建万维网(World Wide Web, WWW)架构而提出的, 经过长时间的演进, 已经能够支持全球规模的超文本系统的各类需求. 架构的很多部分都能够从HTTP的术语和语法上得到体现.

#### 2.1. C/S架构消息

   HTTP是一个无状态的请求/回复协议, 通过一个可靠的传输/会话层「连接」(第6章)交换消息(第3章). 一个HTTP「客户端」(client)是为了发送一个或多个请求, 而与服务器建立了连接(connection)的程序. 一个HTTP「服务器」(server)也是一个程序, 它接受来自客户端的连接, 服务这些客户端的HTTP请求并返回HTTP回复.

   术语「客户端」和「服务器」仅仅是为了区分一个特定连接中不同程序扮演的角色. 同一个程序可以在某些连接中扮演客户端, 而在另一些连接中扮演服务器. 术语「用户代理」(user agent)指代任何一个可以初始化请求的客户端, 包括但不限于浏览器、网络爬虫、命令行工具、定制程序、移动应用等. 对于一个给定的目标资源, 「原始服务器」(origin server)是能对该资源进行权威回复的源头. 术语「发送端」(sender)和「接收端」(recipient)则分别代表发送和接收消息的任意实现.

   HTTP依赖统一资源描述符(Uniform Resource Identifier, URI)来标识目标资源, 以及资源之间的关系. 消息在传输时使用的格式与互联网邮件(Internet mail)、多用途互联网邮件扩展(Multipurpose Internet Mail Extensions, MIME)使用的类似, 查阅附录A以了解它们之间的差异.

   多数HTTP通信中, 存在对指定资源的拉取操作(即GET操作), 这些资源就是通过URI来标识的. 最简单的情况, 这个过程仅需要用户代理(user agent, UA)和原始服务器(O)之间的一个双向连接即可完成.

   >            请求   >
   >    UA ======================================= O
   >                                <   回复

   一个客户端发送给服务器的请求消息依序包含以下内容: 
   - 一个请求行, 包含一个方法, URI, 协议版本;
   - 消息头部, 由一系列消息头部字段组成, 包含请求修饰器(request modifier), 客户端信息, 表征元数据(representation metadata), 消息头部字段以一个空行结尾;
   - 包含有效载荷的消息体(body), 消息体可能为空.

   一个发送一个或多个HTTP回复消息来应答客户端的请求. 回复消息依序包含以下内容：
   - 一个状态行, 包含一个协议版本号, 一个成功/错误码, 成功/错误码的文本解释;
   - 可选的消息头部, 由一系列消息头部字段组成, 包含服务器信息, 资源元数据, 表征元数据, 消息头部字段以一个空行结尾;
   - 包含有效载荷的消息体(body), 消息体可能为空.

   一个连接可以被多轮「请求-回复」复用.

   下面给出一个URI「http://www.example.com/hello.txt」的GET请求示例.

   客户端请求:

   >  GET /hello.txt HTTP/1.1
   >  User-Agent: curl/7.16.3 libcurl/7.16.3 OpenSSL/0.9.7l zlib/1.2.3
   >  Host: www.example.com
   >  Accept-Language: en, mi   
   
   服务器回复:

   >  HTTP/1.1 200 OK
   >  Date: Mon, 27 Jul 2009 12:28:53 GMT
   >  Server: Apache
   >  Last-Modified: Wed, 22 Jul 2009 19:15:56 GMT
   >  ETag: "34aa387-d-1568eb00"
   >  Accept-Ranges: bytes
   >  Content-Length: 51
   >  Vary: Accept-Encoding
   >  Content-Type: text/plain
   >
   >  Hello World! My payload includes a trailing CRLF.

####2.2. 实现差异

   当设计一个HTTP设计, 很容易陷入一个误区, 认为所有的用户代理都是全功能的浏览器, 所有的原始服务器都是大型的公共站点. 现实的情况不是这样的. 典型的用户代理包括日常使用的应用, 立体声音响(stereos?), 电子秤(scales?), 固件升级脚本, 命令行程序, 移动应用, 以及形形色色的通信设备. 类似的, 典型的原始服务器包括家庭自动化系统, 可配置网路组件, 办公机器, 自治机器人, 新闻聚合器, 电子警察, 广告选择器, 视频分发平台等. 

   术语「用户代理」并不意味着, 需要人类用户与软件代理直接交互才能发起请求. 在很多情况下, 用户代理运行在后台, 保存请求结果以供后续使用, 保存的结果可能只是原始结果中感兴趣的部分或者错误信息. 爬虫就是一种典型的用户代理, 给其一个起始URI, 配置链接跟随的行为模式, 就能在超链接形成的图中, 自动运行下去.

   HTTP实现的差异性意味着并不是所有的用户代理都能以界面交互的方式为用户提供建议, 或者在出现安全和隐私问题时给出足够的警示信息. 如果本文档规定一些错误信息必须向用户汇报时, 可以仅将错误记录在错误输出终端或日志文件中. 同样, 一些需要用户确认才能继续的操作, 可以通过高级配置选项, 运行时选项, 不安全选项的方式进行确认. 如果用户已经做过选择, 这种确认可以不必反馈在用户界面或者打断正常的处理流程. (译者注: 就是说, 用户代理可以根据配置选项, 或过去的选择结果, 代替用户进行选择.)

####2.3. 中介

   HTTP允许使用中介程序将连接组织成一条通信链. 常见的中介有代理(proxy)、网关(gateway)、隧道(tunnel)3种. 一些情况下, 一个中介可以扮演原始服务器, 代理, 网关, 或隧道等角色, 并根据每个请求的特征进行角色切换.

   >         >             >             >             >
   >    UA =========== A =========== B =========== C =========== O
   >               <             <             <             <

   上图中, 用户代理和原始服务器间有三个中介, 分别是A, B, C. 每一个请求/回复需要穿过4个独立的连接, 这4个连接形成一条通信链. 这个特征非常重要, 因为一些HTTP通信选项只能在离终端节点最近的非隧道连接上使用. 尽管图中的场景是线性的, 但实际上每一个参与方都可能同时服务于很多连接. 例如, 在处理A请求的同时, B可能接收来自A之外的其它客户端的请求, 转发给除C外的其它服务器. 后续的请求可以使用不同的连接路径进行传输, 连接路径经常因为动态配置或负载均衡的原因发生变化.

   术语「上游」(upstream)和「下游」(downstream)与信息流的传输方向有关: 所有的信息流都是从上游传输到下游. 术语「站内」(inbound)和「站外」(outbound)描述请求路由的方向: 站内和站外分别代表朝向原始路由器和朝向用户代理.

   一个「代理」是一个消息转发代理程序, 对外暴露HTTP接口, 从该接口接收来自客户端的某些类型的绝对URI请求, 并将请求翻译成合适的协议, 以便进一步处理. 有些翻译只需要最低限度的工作, 例如, 仅仅代理转发「http」URI请求; 另外一些则比较「重」, 需要将其翻译成完全不同的应用层协议. 代理的一个常见用途是将一个组织内部的HTTP请求都通过一个中介进行处理, 这个措施有安全性, 注解服务, 共享缓存等方面的考虑. 一些代理会在制定消息或消息负荷被转发时对它们进行转化, 详细细节请参加第5.7.2节.

   一个「网关」(也被称作「反向代理」)是这样一种中介, 对外, 它充当原始服务器, 对内, 它负责将收到的请求转发给内部的其它服务器或服务器集群. 网关的通常用途包括: 封装旧的或不信任的信息服务; 通过「加速器」缓存提高服务器性能; 为多台机器的HTTP服务启用分区或负载均衡.

   所有适用于原始服务器出站通信的要求同样适用于网关. 一个网关和站内服务器可以使用任何协议进行通信, 不限于HTTP及其变种. 当然, 如果需要与第三方HTTP服务交互, 且这些第三方服务器对网关接入的连接有user agent要求, 就需要HTTP-to-HTTP的网关.

   一个「隧道」是两个连接的「盲」中介, 转发而不更改消息内容. 尽管一条隧道可能被HTTP请求初始化, 但一旦启用, 就被当做HTTP通信的一部分. 当两端的连接同时被关闭, 隧道也会随之终止. 隧道被用于通过中介来扩展虚拟连接, 例如, 通过TLS建立能够穿越防火墙的机密连接.

   上述中介的分类是从它们在HTTP通信中扮演的角色划分的. 实际上, 在网络协议栈的底层可能存在其它中介, 这些底层的中介无需知悉HTTP发送者的任何信息, 也无需顾忌发送者是否允许, 就可以对HTTP流量进行过滤和转发. 在「中间人攻击」(man-in-the-middle attack)中, 仅从协议层是无法判断是否存在网络中介的, 这导致误解了HTTP语义, 从而引发安全和互操作问题. 

   HTTP是一个无状态的协议, 每一个请求消息可被独立解释. 许多实现利用HTTP无状态这一点, 重复利用代理连接, 或者在多台服务器间进行请求负载均衡. 因此, 除非连接已经安全绑定到特定的用户代理, 一个服务器**不应该**假设同一连接的两个请求一定来自同一用户代理. 一些非标准的HTTP扩展(RFC4559)必须理解这个要求, 以避免安全和互操作问题.

####2.4. 缓存

   一个「缓存」是对先前已回复消息的本地存储, 由缓存系统控制消息的存储, 获取, 删除. 缓存存储可缓存回复的目的是为了降低未来相同请求的响应时间和网络带宽消耗量. 任何客户端或服务器都**可以**实现一个缓存, 当一个服务器以隧道方式运行时缓存不可使用.

   只要请求/回复链的任何参与方有缓存的回复, 缓存能使请求/回复链的长度缩短. 下图给出了一个示例, 其中, B缓存了来自O(通过C)的旧回复, 这个回复尚未被UA或A缓存.

   >
   >            >             >
   >       UA =========== A =========== B - - - - - - C - - - - - - O
   >                  <             <

   一个回复是「可缓存」的, 如果回复消息的副本允许被存储以应答后续的请求. 当然, 即使一个回复是可缓存的, 客户端或原始服务器仍然可能存在其它限制, 限制缓存的回复被应用于特定的请求. HTTP对缓存行为和可缓存回复的要求在RFC7234第二章定义.

   在万维网和大组织内部, 存在各种缓存架构和配置的变体, 包括:

   - 全国性的分层代理缓存, 能够节省跨洋带宽;
   - 协作系统, 广播/多播缓存记录, 预取后用于改善离线, 高延时等环境下的性能.

####2.5. 一致性和错误处理

   本文档根据HTTP通信中参与方角色来确定一致性标准. 不同的角色, 如发送者, 接收者, 客户端, 服务器, 用户代理, 中介, 原始服务器, 代理, 网关, 缓存, 其行为受到不同要求的约束. 具体的实现, 资源拥有者, 协议元素注册应用在单连接通信外时, 可能会有附加的要求.

   动词「生成」(generate)取代「发送」(send)


超文本传输协议(Hypertext Transfer Protocol, HTTP)是一个无状态的应用层请求/应答协议, 使用可扩展的语法和自描述的消息体, 实现基于网络的超文本信息系统间的信息交互. 本文档是HTTP/1.1协议系列文档的第一篇. 该系列的文档包括:

- 「消息格式与路由」 (this document)

- 「语义与内容」 [RFC7231]

- 「条件请求」 [RFC7232]

- 「范围请求」 [RFC7233]

- 「缓存」 [RFC7234]

- 「认证」 [RFC7235]

本系列文档替代了RFC 2616和RFC 2145. 本系列文档还更新了「使用CONNECT创建隧道」的相关定义, 这之前是在RFC 2817中描述的. 在RFC 2818中非正式引入的「https」URI模式也在本系列文档中被正式定义.

HTTP是为信息系统定义的一个通用接口协议(interface protocol). 它隐藏了服务实现和资源提供的细节, 为客户端提供统一的接口. 同时, 服务器无需关心每一个客户端的意图, 每一个HTTP请求都是相互独立的, 既不与特定的客户端类型绑定, 也不因应用层逻辑而形成依赖关系. 这样做带来的一个好处就是, HTTP适用于许多不同的应用场景, 场景的实现方式可以独立演进.

HTTP还可作为一种中间协议, 翻译来自或发往非HTTP信息系统的通信. HTTP代理(proxy)和网关(gateway)通过将其它协议的内容转化为超文本格式, 使客户端能够像使用HTTP服务一样, 浏览和操作这些内容.

HTTP的灵活性导致的一个后果就是协议背后的行为是未定义的. 取而代之, 我们只定义了通信的语法, 接收通信的意图和接收方预期的行为. 如果通信被认为是相互隔离的, 那么为了反应成功操作带来的改变, 服务器应该提供一些观察接口. 当然, 现实的情况是很多客户端会并发访问服务, 它们的操作可能互相影响, 导致观察到的改变实际上是这些操作的混合结果. 因此, 除了每个请求自身的回复外, 我们不要求每一个操作的改变都能被观察到.

本文档描述HTTP使用和参考的一些基本元素, 包括「http」和「https」URI模式, 网络操作和连接管理, HTTP消息封装和转发要求. 我们的目的是定义处理HTTP消息所必须的全部、语义无关的机制, 这些机制规定了消息解析器和消息转发中介(intermediary)的实现要求.


## 1.1 要求符号

本文档中使用了一些关键字**必须**, **禁止**, **要求**, **应该**, **不应该**, **可以**, **不可以**, **推荐**, **可以**, **可选**. 这些关键字的解释参见RFC 2119.

一致性和错误处理的要求参见2.5节.

## 1.2 语法符号

本文档使用增加了列表扩展(第7章)的扩展巴科斯范式(Augmented Backus-Naur Form, ABNF)(RFC 5234)描述协议语法. 相比于「*」操作符, 增加的列表扩展使用「#」操作符更简洁地表达逗号分隔的列表. 附录B将对此进行描述.

RFC 5234核心的语法规则采用引用的形式进行阐述, 参见附录1, 包括: ALPHA (字母), CR (回车), CRLF (CR LF), CTL (控制字符), DIGIT (数字0-9), DQUOTE (双引号引用), HEXDIG (16进制数字0-9/A-F/a-f), HTAB (水平制表符), LF (换行), OCTET (任何8-bit数据), SP (空格), and VCHAR (任何可见的US-ASCII字符).

凡是以「obs-」开头的规则都是因为各种历史原因被废弃的.
